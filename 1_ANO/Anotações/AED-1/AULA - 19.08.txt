Complexidade de Algoritmos

    Como medir a eficiência de um algoritmo ?
        Duas Variáveis:
            Tempo (-) + complicado
            Espaço (-) (memória) + simples

    Porque não medir o tempo de execução ?
        Depende de fatores externos ao algoritmo (Hardware e Software)

    Objetivo:
        Contar o # de atribuições em um algoritmo
            Duas hipóteses:
                Cada atribuição executa em O(1)
                Função T(n) deve retornar o # de atribuições quando problema possui tamanho "n"
        
    Exemplo:
        Qual a complexidade do seguinte algoritmo ?
            sum_of_n(n){
                soma = 0   // Equivale a 1 atribuição
                for i = 1 to n  
                    soma += i  // Equivale a um Somatório de 1 para n
                return soma
            }
    
        R: 
            = T(n) = Somatório de 1 (n vezes) + 1 = 
            = T(n) = n + 1

Notação Big O

    Definição:
        Seja f(n) uma função p / n >= 0 tal que para c , m > 0 tem-se:
            T(n) <= cf(n)
        Então, dizemos que 
            T(n) é O(f(n))

    Exemplo:
        Qual a complexidade do seguinte algoritmo ?
            sum_of_matrix(m, n){
                soma = 0  //Equivale a 1
                for i = 1 to n{
                    soma_linha = 0      //Equivale a n
                    for j = 1 to n     
                        soma_linha += m[i][j]       //Equivale ao somatorio de (1 + n + 1) para n
                soma += soma_linha      //Equivale a 1
                }
                return soma 
            }

        R: 
            = T(n) = Somatorio de (1 + n + 1) + 1 = 
            = T(n) = Somatorio de 1 para n + Somatorio de n para n + Somatorio de 1 para n + 1 =
            = T(n) = n² + 2n + 1

            Big O = O(n²)
         
    Classe de Funções
        eficiênciente:
            f(n):       Classe:
            c           constantes
            log(n)      logarítmica
            n           linear
            nlog(n)     log - linear

        ok: 
            f(n):       Classe:
            n²          quadrática
            n^k         polinomial

        inviável:
            f(n):       Classe:
            2^n         exponencialk
            n!          fatorial

    Como calcular complexidade de algoritmos ?
        resolver somatórios

        Técnicas

            Somas telescópicas
                Sequências de nº reais: x1, x2, x3.., xn, xn+1
                Somatorio de k = 1 para n (xk+1 - x1) = xn+1 - x1

        Padrões de complexidade comuns de algoritmos:

            Func_A(n){
                c = 0       //Equivale a 1
                for i = 1 to n      // Equivale a somatorio de 1 para n
                    c += 1      // Equivale a 1
                for j = 1 to n      //Equivale a somatorio de 1 para n
                    c += 2      //Equivale a 1 
                return c
            }
            T(n) = 2n + 1 = O(n)

            Func_B(n){
                c = 0
                for i = 1 to n{        //Equivale a somatorio de n para n
                    for j = 1 to n      //Equivale a somatorio de 1 para n
                        c += 1      //Equivale a 1
                } 
            }
            T(n) = n² + 1 = O(n²)

            Func_C(n){
                c = 0
                for i = 1 to n{        //Equivale a somatorio de n para n
                    for j = j to n      //Equivale a somatorio de j para n
                        c += 1      //Equivale a 1
                }
                return c 
            }
            = T(n) = Somatorio de i para n com (i = 1) + 1 =
            = T(n) = n²/2 + n/2 + 1.5 = O(n²)

            Func_D(n){
                c = 0   //Equivale a 1
                i = n   //Equivale a 1
                while i < 1{        //Equivale a ~~ o piso de 2*Log de N na base 2 
                    c += 1      //Equivale a 1
                    i /= 2      //Equivale a 1
                }
                return c 
            }
            T(n) = 2 + 2LogN base 2 = O(Log N base 2)

            Func_E(n){
                c = 0       //Equivale a 1
                for i = 1 to n      // Equivale a somatorio de Log N base 2 para n
                    c += Func_D      // Equivale a O(n) de Func_D = Log N base 2
                return c 
            }
            T(n) = n * Log N base 2 + 1 = O(nlogn)